{
  "version": 3,
  "sources": ["../src/storage/keys.ts", "../src/storage/storage.ts", "../src/utils/base64url.ts", "../src/utils/crypto.ts", "../src/auth/dpop.ts", "../src/auth/pkce.ts", "../src/storage/lock.ts", "../src/auth/tokens.ts", "../src/auth/oauth.ts", "../src/graphql.ts", "../src/client.ts", "../src/errors.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * Storage key constants\n */\nexport const STORAGE_KEYS = {\n  accessToken: 'quickslice_access_token',\n  refreshToken: 'quickslice_refresh_token',\n  tokenExpiresAt: 'quickslice_token_expires_at',\n  clientId: 'quickslice_client_id',\n  userDid: 'quickslice_user_did',\n  codeVerifier: 'quickslice_code_verifier',\n  oauthState: 'quickslice_oauth_state',\n} as const;\n\nexport type StorageKey = (typeof STORAGE_KEYS)[keyof typeof STORAGE_KEYS];\n", "import { STORAGE_KEYS, StorageKey } from './keys';\n\n/**\n * Hybrid storage utility - sessionStorage for OAuth flow state,\n * localStorage for tokens (shared across tabs)\n */\nexport const storage = {\n  get(key: StorageKey): string | null {\n    // OAuth flow state stays in sessionStorage (per-tab)\n    if (key === STORAGE_KEYS.codeVerifier || key === STORAGE_KEYS.oauthState) {\n      return sessionStorage.getItem(key);\n    }\n    // Tokens go in localStorage (shared across tabs)\n    return localStorage.getItem(key);\n  },\n\n  set(key: StorageKey, value: string): void {\n    if (key === STORAGE_KEYS.codeVerifier || key === STORAGE_KEYS.oauthState) {\n      sessionStorage.setItem(key, value);\n    } else {\n      localStorage.setItem(key, value);\n    }\n  },\n\n  remove(key: StorageKey): void {\n    sessionStorage.removeItem(key);\n    localStorage.removeItem(key);\n  },\n\n  clear(): void {\n    Object.values(STORAGE_KEYS).forEach((key) => {\n      sessionStorage.removeItem(key);\n      localStorage.removeItem(key);\n    });\n  },\n};\n", "/**\n * Base64 URL encode a buffer (Uint8Array or ArrayBuffer)\n */\nexport function base64UrlEncode(buffer: ArrayBuffer | Uint8Array): string {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/, '');\n}\n\n/**\n * Generate a random base64url string\n */\nexport function generateRandomString(byteLength: number): string {\n  const bytes = new Uint8Array(byteLength);\n  crypto.getRandomValues(bytes);\n  return base64UrlEncode(bytes);\n}\n", "import { base64UrlEncode } from './base64url';\n\n/**\n * SHA-256 hash, returned as base64url string\n */\nexport async function sha256Base64Url(data: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const hash = await crypto.subtle.digest('SHA-256', encoder.encode(data));\n  return base64UrlEncode(hash);\n}\n\n/**\n * Sign a JWT with an ECDSA P-256 private key\n */\nexport async function signJwt(\n  header: Record<string, unknown>,\n  payload: Record<string, unknown>,\n  privateKey: CryptoKey\n): Promise<string> {\n  const encoder = new TextEncoder();\n\n  const headerB64 = base64UrlEncode(encoder.encode(JSON.stringify(header)));\n  const payloadB64 = base64UrlEncode(encoder.encode(JSON.stringify(payload)));\n\n  const signingInput = `${headerB64}.${payloadB64}`;\n\n  const signature = await crypto.subtle.sign(\n    { name: 'ECDSA', hash: 'SHA-256' },\n    privateKey,\n    encoder.encode(signingInput)\n  );\n\n  const signatureB64 = base64UrlEncode(signature);\n\n  return `${signingInput}.${signatureB64}`;\n}\n", "import { generateRandomString } from '../utils/base64url';\nimport { sha256Base64Url, signJwt } from '../utils/crypto';\n\nconst DB_NAME = 'quickslice-oauth';\nconst DB_VERSION = 1;\nconst KEY_STORE = 'dpop-keys';\nconst KEY_ID = 'dpop-key';\n\ninterface DPoPKeyData {\n  id: string;\n  privateKey: CryptoKey;\n  publicJwk: JsonWebKey;\n  createdAt: number;\n}\n\nlet dbPromise: Promise<IDBDatabase> | null = null;\n\nfunction openDatabase(): Promise<IDBDatabase> {\n  if (dbPromise) return dbPromise;\n\n  dbPromise = new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve(request.result);\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n      if (!db.objectStoreNames.contains(KEY_STORE)) {\n        db.createObjectStore(KEY_STORE, { keyPath: 'id' });\n      }\n    };\n  });\n\n  return dbPromise;\n}\n\nasync function getDPoPKey(): Promise<DPoPKeyData | null> {\n  const db = await openDatabase();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(KEY_STORE, 'readonly');\n    const store = tx.objectStore(KEY_STORE);\n    const request = store.get(KEY_ID);\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve(request.result || null);\n  });\n}\n\nasync function storeDPoPKey(\n  privateKey: CryptoKey,\n  publicJwk: JsonWebKey\n): Promise<void> {\n  const db = await openDatabase();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(KEY_STORE, 'readwrite');\n    const store = tx.objectStore(KEY_STORE);\n    const request = store.put({\n      id: KEY_ID,\n      privateKey,\n      publicJwk,\n      createdAt: Date.now(),\n    });\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve();\n  });\n}\n\nexport async function getOrCreateDPoPKey(): Promise<DPoPKeyData> {\n  const keyData = await getDPoPKey();\n\n  if (keyData) {\n    return keyData;\n  }\n\n  // Generate new P-256 key pair\n  const keyPair = await crypto.subtle.generateKey(\n    { name: 'ECDSA', namedCurve: 'P-256' },\n    false, // NOT extractable - critical for security\n    ['sign']\n  );\n\n  // Export public key as JWK\n  const publicJwk = await crypto.subtle.exportKey('jwk', keyPair.publicKey);\n\n  // Store in IndexedDB\n  await storeDPoPKey(keyPair.privateKey, publicJwk);\n\n  return {\n    id: KEY_ID,\n    privateKey: keyPair.privateKey,\n    publicJwk,\n    createdAt: Date.now(),\n  };\n}\n\n/**\n * Create a DPoP proof JWT\n */\nexport async function createDPoPProof(\n  method: string,\n  url: string,\n  accessToken: string | null = null\n): Promise<string> {\n  const keyData = await getOrCreateDPoPKey();\n\n  // Strip WebCrypto-specific fields from JWK for interoperability\n  const { kty, crv, x, y } = keyData.publicJwk;\n  const minimalJwk = { kty, crv, x, y };\n\n  const header = {\n    alg: 'ES256',\n    typ: 'dpop+jwt',\n    jwk: minimalJwk,\n  };\n\n  const payload: Record<string, unknown> = {\n    jti: generateRandomString(16),\n    htm: method,\n    htu: url,\n    iat: Math.floor(Date.now() / 1000),\n  };\n\n  // Add access token hash if provided (for resource requests)\n  if (accessToken) {\n    payload.ath = await sha256Base64Url(accessToken);\n  }\n\n  return await signJwt(header, payload, keyData.privateKey);\n}\n\n/**\n * Clear DPoP keys from IndexedDB\n */\nexport async function clearDPoPKeys(): Promise<void> {\n  const db = await openDatabase();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(KEY_STORE, 'readwrite');\n    const store = tx.objectStore(KEY_STORE);\n    const request = store.clear();\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve();\n  });\n}\n", "import { base64UrlEncode, generateRandomString } from '../utils/base64url';\n\n/**\n * Generate a PKCE code verifier (32 random bytes, base64url encoded)\n */\nexport function generateCodeVerifier(): string {\n  return generateRandomString(32);\n}\n\n/**\n * Generate a PKCE code challenge from a verifier (SHA-256, base64url encoded)\n */\nexport async function generateCodeChallenge(verifier: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(verifier);\n  const hash = await crypto.subtle.digest('SHA-256', data);\n  return base64UrlEncode(hash);\n}\n\n/**\n * Generate a random state parameter for CSRF protection\n */\nexport function generateState(): string {\n  return generateRandomString(16);\n}\n", "const LOCK_TIMEOUT = 5000; // 5 seconds\nconst LOCK_PREFIX = 'quickslice_lock_';\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Acquire a lock using localStorage for multi-tab coordination\n */\nexport async function acquireLock(\n  key: string,\n  timeout = LOCK_TIMEOUT\n): Promise<string | null> {\n  const lockKey = LOCK_PREFIX + key;\n  const lockValue = `${Date.now()}_${Math.random()}`;\n  const deadline = Date.now() + timeout;\n\n  while (Date.now() < deadline) {\n    const existing = localStorage.getItem(lockKey);\n\n    if (existing) {\n      // Check if lock is stale (older than timeout)\n      const [timestamp] = existing.split('_');\n      if (Date.now() - parseInt(timestamp) > LOCK_TIMEOUT) {\n        // Lock is stale, remove it\n        localStorage.removeItem(lockKey);\n      } else {\n        // Lock is held, wait and retry\n        await sleep(50);\n        continue;\n      }\n    }\n\n    // Try to acquire\n    localStorage.setItem(lockKey, lockValue);\n\n    // Verify we got it (handle race condition)\n    await sleep(10);\n    if (localStorage.getItem(lockKey) === lockValue) {\n      return lockValue; // Lock acquired\n    }\n  }\n\n  return null; // Failed to acquire\n}\n\n/**\n * Release a lock\n */\nexport function releaseLock(key: string, lockValue: string): void {\n  const lockKey = LOCK_PREFIX + key;\n  // Only release if we still hold it\n  if (localStorage.getItem(lockKey) === lockValue) {\n    localStorage.removeItem(lockKey);\n  }\n}\n", "import { storage } from '../storage/storage';\nimport { STORAGE_KEYS } from '../storage/keys';\nimport { acquireLock, releaseLock } from '../storage/lock';\nimport { createDPoPProof } from './dpop';\n\nconst TOKEN_REFRESH_BUFFER_MS = 60000; // 60 seconds before expiry\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Refresh tokens using the refresh token\n */\nasync function refreshTokens(tokenUrl: string): Promise<string> {\n  const refreshToken = storage.get(STORAGE_KEYS.refreshToken);\n  const clientId = storage.get(STORAGE_KEYS.clientId);\n\n  if (!refreshToken || !clientId) {\n    throw new Error('No refresh token available');\n  }\n\n  const dpopProof = await createDPoPProof('POST', tokenUrl);\n\n  const response = await fetch(tokenUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      DPoP: dpopProof,\n    },\n    body: new URLSearchParams({\n      grant_type: 'refresh_token',\n      refresh_token: refreshToken,\n      client_id: clientId,\n    }),\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(\n      `Token refresh failed: ${errorData.error_description || response.statusText}`\n    );\n  }\n\n  const tokens = await response.json();\n\n  // Store new tokens (rotation - new refresh token each time)\n  storage.set(STORAGE_KEYS.accessToken, tokens.access_token);\n  if (tokens.refresh_token) {\n    storage.set(STORAGE_KEYS.refreshToken, tokens.refresh_token);\n  }\n\n  const expiresAt = Date.now() + tokens.expires_in * 1000;\n  storage.set(STORAGE_KEYS.tokenExpiresAt, expiresAt.toString());\n\n  return tokens.access_token;\n}\n\n/**\n * Get a valid access token, refreshing if necessary.\n * Uses multi-tab locking to prevent duplicate refresh requests.\n */\nexport async function getValidAccessToken(tokenUrl: string): Promise<string> {\n  const accessToken = storage.get(STORAGE_KEYS.accessToken);\n  const expiresAt = parseInt(storage.get(STORAGE_KEYS.tokenExpiresAt) || '0');\n\n  // Check if token is still valid (with buffer)\n  if (accessToken && Date.now() < expiresAt - TOKEN_REFRESH_BUFFER_MS) {\n    return accessToken;\n  }\n\n  // Need to refresh - acquire lock first\n  const clientId = storage.get(STORAGE_KEYS.clientId);\n  const lockKey = `token_refresh_${clientId}`;\n  const lockValue = await acquireLock(lockKey);\n\n  if (!lockValue) {\n    // Failed to acquire lock, another tab is refreshing\n    // Wait a bit and check cache again\n    await sleep(100);\n    const freshToken = storage.get(STORAGE_KEYS.accessToken);\n    const freshExpiry = parseInt(\n      storage.get(STORAGE_KEYS.tokenExpiresAt) || '0'\n    );\n    if (freshToken && Date.now() < freshExpiry - TOKEN_REFRESH_BUFFER_MS) {\n      return freshToken;\n    }\n    throw new Error('Failed to refresh token');\n  }\n\n  try {\n    // Double-check after acquiring lock\n    const freshToken = storage.get(STORAGE_KEYS.accessToken);\n    const freshExpiry = parseInt(\n      storage.get(STORAGE_KEYS.tokenExpiresAt) || '0'\n    );\n    if (freshToken && Date.now() < freshExpiry - TOKEN_REFRESH_BUFFER_MS) {\n      return freshToken;\n    }\n\n    // Actually refresh\n    return await refreshTokens(tokenUrl);\n  } finally {\n    releaseLock(lockKey, lockValue);\n  }\n}\n\n/**\n * Store tokens from OAuth response\n */\nexport function storeTokens(tokens: {\n  access_token: string;\n  refresh_token?: string;\n  expires_in: number;\n  sub?: string;\n}): void {\n  storage.set(STORAGE_KEYS.accessToken, tokens.access_token);\n  if (tokens.refresh_token) {\n    storage.set(STORAGE_KEYS.refreshToken, tokens.refresh_token);\n  }\n\n  const expiresAt = Date.now() + tokens.expires_in * 1000;\n  storage.set(STORAGE_KEYS.tokenExpiresAt, expiresAt.toString());\n\n  if (tokens.sub) {\n    storage.set(STORAGE_KEYS.userDid, tokens.sub);\n  }\n}\n\n/**\n * Check if we have a valid session\n */\nexport function hasValidSession(): boolean {\n  const accessToken = storage.get(STORAGE_KEYS.accessToken);\n  const refreshToken = storage.get(STORAGE_KEYS.refreshToken);\n  return !!(accessToken || refreshToken);\n}\n", "import { storage } from '../storage/storage';\nimport { STORAGE_KEYS } from '../storage/keys';\nimport { createDPoPProof, clearDPoPKeys } from './dpop';\nimport { generateCodeVerifier, generateCodeChallenge, generateState } from './pkce';\nimport { storeTokens } from './tokens';\n\nexport interface LoginOptions {\n  handle?: string;\n}\n\n/**\n * Initiate OAuth login flow with PKCE\n */\nexport async function initiateLogin(\n  authorizeUrl: string,\n  clientId: string,\n  options: LoginOptions = {}\n): Promise<void> {\n  const codeVerifier = generateCodeVerifier();\n  const codeChallenge = await generateCodeChallenge(codeVerifier);\n  const state = generateState();\n\n  // Store for callback\n  storage.set(STORAGE_KEYS.codeVerifier, codeVerifier);\n  storage.set(STORAGE_KEYS.oauthState, state);\n  storage.set(STORAGE_KEYS.clientId, clientId);\n\n  // Build redirect URI (current page without query params)\n  const redirectUri = window.location.origin + window.location.pathname;\n\n  // Build authorization URL\n  const params = new URLSearchParams({\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    response_type: 'code',\n    code_challenge: codeChallenge,\n    code_challenge_method: 'S256',\n    state: state,\n  });\n\n  if (options.handle) {\n    params.set('login_hint', options.handle);\n  }\n\n  window.location.href = `${authorizeUrl}?${params.toString()}`;\n}\n\n/**\n * Handle OAuth callback - exchange code for tokens\n * Returns true if callback was handled, false if not a callback\n */\nexport async function handleOAuthCallback(tokenUrl: string): Promise<boolean> {\n  const params = new URLSearchParams(window.location.search);\n  const code = params.get('code');\n  const state = params.get('state');\n  const error = params.get('error');\n\n  if (error) {\n    throw new Error(\n      `OAuth error: ${error} - ${params.get('error_description') || ''}`\n    );\n  }\n\n  if (!code || !state) {\n    return false; // Not a callback\n  }\n\n  // Verify state\n  const storedState = storage.get(STORAGE_KEYS.oauthState);\n  if (state !== storedState) {\n    throw new Error('OAuth state mismatch - possible CSRF attack');\n  }\n\n  // Get stored values\n  const codeVerifier = storage.get(STORAGE_KEYS.codeVerifier);\n  const clientId = storage.get(STORAGE_KEYS.clientId);\n  const redirectUri = window.location.origin + window.location.pathname;\n\n  if (!codeVerifier || !clientId) {\n    throw new Error('Missing OAuth session data');\n  }\n\n  // Exchange code for tokens with DPoP\n  const dpopProof = await createDPoPProof('POST', tokenUrl);\n\n  const tokenResponse = await fetch(tokenUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      DPoP: dpopProof,\n    },\n    body: new URLSearchParams({\n      grant_type: 'authorization_code',\n      code: code,\n      redirect_uri: redirectUri,\n      client_id: clientId,\n      code_verifier: codeVerifier,\n    }),\n  });\n\n  if (!tokenResponse.ok) {\n    const errorData = await tokenResponse.json().catch(() => ({}));\n    throw new Error(\n      `Token exchange failed: ${errorData.error_description || tokenResponse.statusText}`\n    );\n  }\n\n  const tokens = await tokenResponse.json();\n\n  // Store tokens\n  storeTokens(tokens);\n\n  // Clean up OAuth state\n  storage.remove(STORAGE_KEYS.codeVerifier);\n  storage.remove(STORAGE_KEYS.oauthState);\n\n  // Clear URL params\n  window.history.replaceState({}, document.title, window.location.pathname);\n\n  return true;\n}\n\n/**\n * Logout - clear all stored data\n */\nexport async function logout(options: { reload?: boolean } = {}): Promise<void> {\n  storage.clear();\n  await clearDPoPKeys();\n\n  if (options.reload !== false) {\n    window.location.reload();\n  }\n}\n", "import { createDPoPProof } from './auth/dpop';\nimport { getValidAccessToken } from './auth/tokens';\n\nexport interface GraphQLResponse<T = unknown> {\n  data?: T;\n  errors?: Array<{ message: string; path?: string[] }>;\n}\n\n/**\n * Execute a GraphQL query or mutation\n */\nexport async function graphqlRequest<T = unknown>(\n  graphqlUrl: string,\n  tokenUrl: string,\n  query: string,\n  variables: Record<string, unknown> = {},\n  requireAuth = false\n): Promise<T> {\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n  };\n\n  if (requireAuth) {\n    const token = await getValidAccessToken(tokenUrl);\n    if (!token) {\n      throw new Error('Not authenticated');\n    }\n\n    // Create DPoP proof bound to this request\n    const dpopProof = await createDPoPProof('POST', graphqlUrl, token);\n\n    headers['Authorization'] = `DPoP ${token}`;\n    headers['DPoP'] = dpopProof;\n  }\n\n  const response = await fetch(graphqlUrl, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ query, variables }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`GraphQL request failed: ${response.statusText}`);\n  }\n\n  const result: GraphQLResponse<T> = await response.json();\n\n  if (result.errors && result.errors.length > 0) {\n    throw new Error(`GraphQL error: ${result.errors[0].message}`);\n  }\n\n  return result.data as T;\n}\n", "import { storage } from './storage/storage';\nimport { STORAGE_KEYS } from './storage/keys';\nimport { getOrCreateDPoPKey } from './auth/dpop';\nimport { initiateLogin, handleOAuthCallback, logout as doLogout, LoginOptions } from './auth/oauth';\nimport { getValidAccessToken, hasValidSession } from './auth/tokens';\nimport { graphqlRequest } from './graphql';\n\nexport interface QuicksliceClientOptions {\n  server: string;\n  clientId: string;\n}\n\nexport interface User {\n  did: string;\n}\n\nexport class QuicksliceClient {\n  private server: string;\n  private clientId: string;\n  private graphqlUrl: string;\n  private authorizeUrl: string;\n  private tokenUrl: string;\n  private initialized = false;\n\n  constructor(options: QuicksliceClientOptions) {\n    this.server = options.server.replace(/\\/$/, ''); // Remove trailing slash\n    this.clientId = options.clientId;\n\n    this.graphqlUrl = `${this.server}/graphql`;\n    this.authorizeUrl = `${this.server}/oauth/authorize`;\n    this.tokenUrl = `${this.server}/oauth/token`;\n  }\n\n  /**\n   * Initialize the client - must be called before other methods\n   */\n  async init(): Promise<void> {\n    if (this.initialized) return;\n\n    // Ensure DPoP key exists\n    await getOrCreateDPoPKey();\n\n    this.initialized = true;\n  }\n\n  /**\n   * Start OAuth login flow\n   */\n  async loginWithRedirect(options: LoginOptions = {}): Promise<void> {\n    await this.init();\n    await initiateLogin(this.authorizeUrl, this.clientId, options);\n  }\n\n  /**\n   * Handle OAuth callback after redirect\n   * Returns true if callback was handled\n   */\n  async handleRedirectCallback(): Promise<boolean> {\n    await this.init();\n    return await handleOAuthCallback(this.tokenUrl);\n  }\n\n  /**\n   * Logout and clear all stored data\n   */\n  async logout(options: { reload?: boolean } = {}): Promise<void> {\n    await doLogout(options);\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  async isAuthenticated(): Promise<boolean> {\n    return hasValidSession();\n  }\n\n  /**\n   * Get current user's DID (from stored token data)\n   * For richer profile info, use client.query() with your own schema\n   */\n  getUser(): User | null {\n    if (!hasValidSession()) {\n      return null;\n    }\n\n    const did = storage.get(STORAGE_KEYS.userDid);\n    if (!did) {\n      return null;\n    }\n\n    return { did };\n  }\n\n  /**\n   * Get access token (auto-refreshes if needed)\n   */\n  async getAccessToken(): Promise<string> {\n    await this.init();\n    return await getValidAccessToken(this.tokenUrl);\n  }\n\n  /**\n   * Execute a GraphQL query (authenticated)\n   */\n  async query<T = unknown>(\n    query: string,\n    variables: Record<string, unknown> = {}\n  ): Promise<T> {\n    await this.init();\n    return await graphqlRequest<T>(\n      this.graphqlUrl,\n      this.tokenUrl,\n      query,\n      variables,\n      true\n    );\n  }\n\n  /**\n   * Execute a GraphQL mutation (authenticated)\n   */\n  async mutate<T = unknown>(\n    mutation: string,\n    variables: Record<string, unknown> = {}\n  ): Promise<T> {\n    return this.query<T>(mutation, variables);\n  }\n\n  /**\n   * Execute a public GraphQL query (no auth)\n   */\n  async publicQuery<T = unknown>(\n    query: string,\n    variables: Record<string, unknown> = {}\n  ): Promise<T> {\n    await this.init();\n    return await graphqlRequest<T>(\n      this.graphqlUrl,\n      this.tokenUrl,\n      query,\n      variables,\n      false\n    );\n  }\n}\n", "/**\n * Base error class for Quickslice client errors\n */\nexport class QuicksliceError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'QuicksliceError';\n  }\n}\n\n/**\n * Thrown when authentication is required but user is not logged in\n */\nexport class LoginRequiredError extends QuicksliceError {\n  constructor(message = 'Login required') {\n    super(message);\n    this.name = 'LoginRequiredError';\n  }\n}\n\n/**\n * Thrown when network request fails\n */\nexport class NetworkError extends QuicksliceError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NetworkError';\n  }\n}\n\n/**\n * Thrown when OAuth flow fails\n */\nexport class OAuthError extends QuicksliceError {\n  public code: string;\n  public description?: string;\n\n  constructor(code: string, description?: string) {\n    super(`OAuth error: ${code}${description ? ` - ${description}` : ''}`);\n    this.name = 'OAuthError';\n    this.code = code;\n    this.description = description;\n  }\n}\n", "export { QuicksliceClient, QuicksliceClientOptions, User } from './client';\nexport {\n  QuicksliceError,\n  LoginRequiredError,\n  NetworkError,\n  OAuthError,\n} from './errors';\n\nimport { QuicksliceClient, QuicksliceClientOptions } from './client';\n\n/**\n * Create and initialize a Quickslice client\n */\nexport async function createQuicksliceClient(\n  options: QuicksliceClientOptions\n): Promise<QuicksliceClient> {\n  const client = new QuicksliceClient(options);\n  await client.init();\n  return client;\n}\n"],
  "mappings": "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",
  "names": ["sleep"]
}
