[{"path":"/","title":"Introduction","group":"Getting Started","content":"quickslice An AppView (backend service) for AT Protocol apps. ## What is quickslice? Quickslice gives you a GraphQL API and OAuth authentication for AT Protocol data. Point it at any Lexicon schemas, and it automatically generates a complete backend: queries, mutations, joins, subscriptions, and user authentication via AT Protocol identity. Instead of building your own data layer and auth system, you get: - GraphQL API generated from your Lexicon definitions - OAuth proxy that authenticates users via their AT Protocol identity (Bluesky, etc.) - Real-time ingestion of records from the AT Protocol network ## Core Concepts ### GraphQL API Your Lexicon schemas become GraphQL types automatically. Query records with filtering, sorting, and pagination: ### OAuth Authentication Users authenticate with their AT Protocol identity (e.g., their Bluesky account). Quickslice acts as an OAuth proxy—your app never handles credentials directly. Authenticated users can create, update, and delete their own records. ### Records Records are the data units in AT Protocol, defined by Lexicon schemas. Quickslice ingests records from the network and stores them locally for fast querying. Mutations write records back to the user's repository (PDS). ## Getting Started Endpoints: - - GraphQL API - - Interactive GraphQL explorer - - OAuth authorization endpoint Queries are public. Mutations require authentication via Bearer token.","headings":[]},{"path":"/quickstart","title":"Quickstart","group":"Getting Started","content":"Quickstart: Deploy on Railway Get a quickslice instance running in a few minutes. By the end, you'll have: - A live GraphQL API for your AT Protocol app - OAuth authentication via AT Protocol identity - Real-time data ingestion from the network ## Prerequisites - AT Protocol account - A Bluesky account or other AT Protocol identity - Lexicon files - JSON files defining your app's data schema > New to Lexicons? > Lexicons are JSON schemas that define record types in AT Protocol (similar to > database tables). Each lexicon has an NSID like . See the > AT Protocol Lexicon docs to create yours. ## 1. Deploy to Railway Click the button below to create a new quickslice instance: Railway will prompt you to configure environment variables. Leave the form open. You'll need to generate a signing key next. ## 2. Generate OAuth Signing Key Quickslice needs a private key to sign OAuth tokens. You'll generate this using , a CLI for AT Protocol. Install goat: > What is goat? > Goat is a > general-purpose CLI for AT Protocol operations: key generation, identity > resolution, record inspection, and more. Generate the key: This outputs a P-256 private key. Copy the entire output. > Why P-256? > AT Protocol's OAuth implementation uses DPoP (Demonstrating Proof of Possession) > to bind tokens to a specific key. The P-256 elliptic curve is required for > signing these proofs. Paste into Railway: 1. Paste the key into the field 2. Click Save Config ## 3. Configure Your Domain After saving the config, Railway deploys your instance. Once deployment completes: 1. Click on your quickslice service in the deployment canvas 2. Go to Settings 3. Click Generate Domain under the Networking section Railway creates a public URL (e.g., ). Redeploy to apply the domain: 1. Go to the Deployments tab 2. Click the three-dot menu on the latest deployment 3. Select Redeploy This ensures quickslice knows its public URL for OAuth redirects. ## 4. Create Admin Account Visit your new domain. You'll see a welcome screen prompting you to create an admin account. 1. Enter your AT Protocol handle (e.g., ) 2. Click Authenticate 3. You'll be redirected to your PDS to authorize quickslice 4. After authorization, you're returned to the quickslice homepage as admin > What just happened? > Quickslice authenticated you via AT Protocol OAuth. Your PDS verified your > identity, and quickslice now recognizes your DID as the instance admin. ## 5. Configure Your Instance From the quickslice homepage, go to Settings. Set your Domain Authority: Enter your domain authority in reverse-domain format (e.g., ). > What is Domain Authority? > Domain authority is the namespace prefix for your lexicons. If your lexicons > are named and , your domain authority > is . This must match the prefix in your lexicon files. Click Save. Upload your Lexicons: Prepare a file containing your lexicon JSON files: Each file should be a valid Lexicon schema. 1. Click Upload Lexicons 2. Select your file 3. Quickslice validates and registers each lexicon > Validation Errors? > Lexicon schemas are validated on import and will fail if incorrectly defined. > If you encounter validation errors, try glot > to check your schemas locally before uploading. ## 6. Backfill Network Data Return to the quickslice homepage and click Trigger Backfill. This scans the AT Protocol network for existing records matching your lexicons and imports them into your instance. > Monitoring Progress > Backfill duration depends on how many matching records exist across the network. > You can monitor progress in the Railway logs (Deployments → View Logs). The page > will refresh when backfill completes. ## 7. Start Querying Once backfill finishes, click Open GraphiQL to access the interactive GraphQL explorer. Try a sample query: Your quickslice instance is now live.","headings":[]},{"path":"/building-apps","title":"Building Apps","group":"Getting Started","content":"Building Apps You have a Quickslice instance running. Now build an app that authenticates users and interacts with its GraphQL API. ## Prerequisites - Running Quickslice instance - Follow the Quickstart if you haven't deployed one yet - Your instance URL - e.g., > Live Example > See the complete working app on StackBlitz or browse the source code. ## How Authentication Works Quickslice acts as an OAuth proxy between your app and users' Personal Data Servers (PDS): 1. Your app redirects users to Quickslice's authorize endpoint 2. Quickslice resolves the user's DID and locates their PDS 3. The user authenticates with their PDS (e.g., Bluesky) 4. Quickslice issues your app an access token Your app never handles AT Protocol credentials directly. The access token authorizes GraphQL mutations that write records to the user's repository. ### Security: PKCE and DPoP The Quickslice client SDK implements two security mechanisms that protect browser-based apps: PKCE (Proof Key for Code Exchange) prevents authorization code interception attacks. Before redirecting to login, the SDK generates a random secret (code verifier) and sends only its hash (code challenge) to the server. When exchanging the authorization code for tokens, the SDK proves it initiated the request by providing the original verifier. DPoP (Demonstrating Proof-of-Possession) binds tokens to a cryptographic key stored in your browser. Each request includes a signed proof that the token holder possesses the private key. Even if an attacker steals your access token, they can't use it without the key. Together, these mechanisms provide security comparable to confidential clients—without requiring server-side secrets. ## 1. Create an OAuth Client Before implementing authentication, register an OAuth client in your Quickslice instance. ### Public vs Confidential Clients Choose based on where your code runs: | Type | Use Case | Secret | |------|----------|--------| | Public | Browser apps (SPAs), mobile apps | No secret — can't be kept secure on client | | Confidential | Server-side apps, backend services | Has secret — stored securely on server | Most browser-based apps use Public clients. If you're building a server-rendered app or using a Backend-for-Frontend pattern, use Confidential. ### Register Your Client 1. Open your Quickslice instance and navigate to Settings 2. Scroll to OAuth Clients and click Register New Client 3. Fill in the form: - Client Name: Your app's name (e.g., \"My Status App\") - Client Type: Select \"Public\" for browser apps - Redirect URIs: Where users return after auth (e.g., ) - Scope: Leave as 4. Click Create 5. Copy the Client ID — you'll need this in your app ## 2. Install the SDK The Quickslice client SDK handles OAuth, PKCE, DPoP, token refresh, and GraphQL requests. ### npm ### CDN The SDK exposes and globally. ## 3. Implement Authentication ### Initialize the Client Create a client instance with your server URL and OAuth client ID: ### Login Redirect the user to authenticate with their AT Protocol identity: ### Handle the Callback After authentication, the user returns to your app. Handle the callback to complete login: The SDK automatically exchanges the authorization code for tokens using PKCE and DPoP, stores them securely, and cleans up the URL. ### Check Authentication State ### Logout ## 4. Query the GraphQL API ### Public Queries Use for unauthenticated requests. All queries are public by default: ### Authenticated Queries Use for requests that require authentication. The SDK automatically includes the access token with DPoP proof: ## 5. Create Records with Mutations Use to create records in the user's AT Protocol repository: The mutation returns the created record, including its (the AT Protocol record identifier). ## 6. Confidential Clients Use a confidential client when your app has a secure backend that can store secrets. ### When to Use - Server-rendered applications (Node.js, Python, etc.) - Backend-for-Frontend (BFF) pattern - Mobile apps with a backend proxy ### Differences from Public Clients 1. Select Confidential when registering the client 2. You receive both a Client ID and Client Secret 3. Include the secret in the token exchange ### Token Exchange The only code difference is adding to the token request: > Security Note: Never expose the client secret in browser code. This request must happen on your server.","headings":[]},{"path":"/authentication","title":"Authentication","group":"Getting Started","content":"Authentication Queries are public and require no authentication. Mutations require a valid access token. The query returns the authenticated user's information, or if not authenticated. ## How it works Quickslice acts as an OAuth proxy between your app and the user's PDS (Personal Data Server). When a user logs in: 1. Your app redirects to quickslice's OAuth authorize endpoint with the user's handle 2. Quickslice resolves the user's DID and locates their PDS 3. The user authenticates with their PDS 4. Quickslice issues your app an access token Your app never handles AT Protocol credentials directly. The access token authorizes mutations that write records to the user's repository on their PDS. ## OAuth Endpoints - - Start the OAuth flow (redirect users here) - - Exchange authorization code for tokens - - Server metadata - - Client metadata (used by AT Protocol for client discovery) ### Prerequisites You need an OAuth client ID. Create one in the quickslice admin UI at . ## Using Tokens Include the access token in the header: ## Viewer Query The query returns the authenticated user: - - The user's decentralized identifier (e.g., ) - - The user's handle (e.g., ) - Returns when not authenticated (no error) You can use the viewer's DID to reverse join to any record type in your system. For example, if you have a profile lexicon:","headings":[]},{"path":"/queries","title":"Queries","group":"GraphQL","content":"Queries > Note: Queries are public and do not require authentication. ## Basic Query Fetch records using Relay-style connections: ## Filtering Use the argument to filter records: ### Filter Operators - : Equal to - : Not equal to - : In array - : String contains (case-insensitive) ### Example Filters ## Sorting Sort records using the argument: ### Sort Multiple Fields ## Pagination (Relay Cursor Connections) ### Forward Pagination Use and to paginate forward: Next page: ### Backward Pagination Use and to paginate backward: ## PageInfo Fields The object contains: - : Boolean indicating if more items exist after this page - : Boolean indicating if more items exist before this page - : Cursor of the first item in the current page - : Cursor of the last item in the current page ## Complete Example Combining filters, sorting, and pagination: Variables: ## Pagination Pattern Here's a typical pagination flow: 1. First page: 2. Check if there's a next page: 3. Fetch next page: 4. Continue until is","headings":[]},{"path":"/mutations","title":"Mutations","group":"GraphQL","content":"Mutations > Note: All mutations require authentication. Include your Bearer token in the header. ## Create Record Create a new record: ### With Custom rkey Provide a custom record key (rkey): ## Update Record Update an existing record: ## Delete Record Delete a record: ## Working with Blobs ### Upload Blob First, upload binary data as a blob: Response: ### Use Blob in Record Use the blob reference in a record: ### Update Profile with Avatar and Banner ## Blob URLs Blobs automatically generate CDN URLs. You can specify a preset for different sizes: Available presets: - - Small square image - - Large horizontal image - - Thumbnail for feed - - Full size for feed (default)","headings":[]},{"path":"/joins","title":"Joins","group":"GraphQL","content":"Joins quickslice automatically generates forward joins, reverse joins, and DID joins based on your lexicon schemas, allowing you to traverse relationships between records. > Note: The examples in this document use Grain's lexicons. The same join patterns apply to any AT Protocol lexicons you load into quickslice. ## Overview - Forward Joins: Follow references from one record to another (e.g., comment → photo it's about) - Returns: Single object or union - Naming: - Reverse Joins: Discover records that reference a given record (e.g., photo → all favorites on it) - Returns: Paginated Connection with sorting, filtering, and pagination - Naming: - DID Joins: Find records that share the same author (DID) - Returns: Single object (unique DID) or Paginated Connection (non-unique DID) - Naming: - Union Types: Forward joins return a union, allowing type-specific field access via inline fragments ## Forward Joins Forward joins are generated for fields that reference other records via: - format strings - objects (containing and ) ### Resolving Favorite Subjects Favorites have a field containing an AT-URI. This gets a field to fetch the actual record: ### Union Types & Inline Fragments Forward join fields return a union type because the referenced record could be any type. Use inline fragments to access type-specific fields: ### Gallery Item Forward Joins Gallery items link photos to galleries. Both references can be resolved: ## Reverse Joins Reverse joins are automatically discovered by analyzing all lexicons. They allow you to find all records that reference a given record. Reverse joins return paginated connections with support for sorting, filtering, and cursor-based pagination. ### Favorites on a Photo Find all users who favorited a specific photo: ### Comments on a Gallery Find all comments on a gallery: ### Sorting Reverse Joins Sort reverse join results by any field in the joined collection: ### Filtering Reverse Joins Use filters to narrow down nested join results: ## DID Joins DID joins allow you to traverse relationships between records that share the same author (DID). These are automatically generated for all collection pairs and are named: ### Two Types of DID Joins #### 1. Unique DID Joins (literal:self key) Collections with a key (like profiles) have only one record per DID. These return a single nullable object (no pagination needed): #### 2. Non-Unique DID Joins Most collections can have multiple records per DID. These return paginated connections with full support for sorting, filtering, and pagination: ### User's Photos Get a user's recent photos from their profile: ### User's Galleries Get all galleries created by a user: ### User's Favorites Get what a user has favorited: ### Cross-Collection DID Queries DID joins work across all collection pairs, enabling powerful cross-collection queries: ### From Photo to Author Profile Navigate from any photo back to the author's full profile: ### Cross-Lexicon DID Joins (Bluesky Profile) DID joins work across different lexicon families. Get a user's Bluesky profile alongside their Grain data: ### DID Join Arguments Non-unique DID joins support all standard connection arguments: | Argument | Type | Description | |----------|------|-------------| | | | Number of records to return (forward pagination) | | | | Cursor for forward pagination | | | | Number of records to return (backward pagination) | | | | Cursor for backward pagination | | | | Sort by any field in the collection | | | | Filter nested records | ## Complete Example Combining forward joins, reverse joins, and DID joins to build a rich gallery view: ## DataLoader Batching All joins use DataLoader for efficient batching: How it works: 1. Fetches 100 photos 2. Collects all unique DIDs from those photos 3. Batches them into a single SQL query: 4. Returns resolved profiles efficiently ## Type Resolution The union uses a type resolver that examines the field: | Collection | GraphQL Type | |------------|--------------| | | | | | | | | | | | | This allows inline fragments to work correctly: ## Schema Introspection Discover available joins using introspection: Look for fields ending in: - (forward joins) - (reverse joins) - (DID joins)","headings":[]},{"path":"/aggregations","title":"Aggregations","group":"GraphQL","content":"Aggregations All record types have a corresponding aggregation query: . For example, records can be aggregated with . Aggregation queries are public and do not require authentication. ## Basic Aggregation Group by a field to count occurrences: ## Filtering & Sorting Use to filter records, to sort by count, and to cap results. Get a user's top 10 artists for 2025: ## Multiple Fields Group by multiple fields simultaneously. Get top tracks with their artists: ## Date Truncation Group datetime fields by time intervals: , , , or . Get plays per month: ## Reference ### Query Structure - - Aggregation query for any record type - (required) - Array of fields to group by, with optional for datetime fields - (optional) - Filter conditions - (optional) - Sort by ( or ) - (optional) - Maximum groups to return (default: 100) ### Available Columns In addition to record fields, you can group by: , , , , , ### Validation - Date intervals can only be applied to datetime fields - Maximum 5 groupBy fields per query","headings":[]},{"path":"/subscriptions","title":"Subscriptions","group":"GraphQL","content":"Subscriptions > Note: Subscriptions require a WebSocket connection. Connect to using the protocol. ## Basic Subscription Subscribe to new records: ## Field Selection Request only the fields you need: Response: ## Named Subscription ## Subscription Types Each collection has three subscription fields: - - Fires when a new record is created - - Fires when a record is updated - - Fires when a record is deleted ### Examples ## With Joins Subscriptions support joins like queries: Response: ## WebSocket Protocol ### 1. Connect ### 2. Initialize ### 3. Subscribe ### 4. Receive Events ### 5. Unsubscribe","headings":[]},{"path":"/blobs","title":"Blobs","group":"GraphQL","content":"Working with Blobs Blobs are used for binary data like images, videos, and files. They are uploaded separately and referenced by their CID (Content Identifier). ## Upload Blob Upload binary data encoded as base64: Response: ## Blob Reference A blob reference contains: - : CID of the blob content - : MIME type (e.g., , ) - : Size in bytes ## Using Blobs in Records ### Profile Avatar ### Profile Banner ## Blob URLs Blobs automatically generate CDN URLs for serving. Use the field with optional presets: ### Default URL Returns: ### Avatar Preset Returns: ### Banner Preset Returns: ## Available Presets - - Optimized for profile avatars (square, small) - - Optimized for profile banners (wide, medium) - - Thumbnails in feed view - - Full size images in feed (default) ## Complete Example: Update Profile with Images ### Step 1: Upload Avatar Variables: Response: ### Step 2: Upload Banner Variables: Response: ### Step 3: Update Profile Response: ## JavaScript Example","headings":[]},{"path":"/variables","title":"Variables","group":"GraphQL","content":"Variables GraphQL variables allow you to parameterize your queries and mutations for reusability and security. ## Basic Variables ### Query with Variables Variables: ### Mutation with Variables Variables: ## Multiple Variables Variables: ## Optional Variables Use default values for optional variables: Variables: Or omit variables to use defaults: ## Blob Upload with Variables Variables: ## Update Profile with Variables Variables: ## Using in HTTP Requests When making HTTP requests, send variables in the request body:","headings":[]},{"path":"/deployment","title":"Deployment","group":"Other","content":"Deployment (WIP) This guide covers deploying quickslice on Fly.io and Railway. Both platforms support Docker deployments with persistent volumes for SQLite. ## Environment Variables | Variable | Required | Default | Description | |----------|----------|---------|-------------| | | No | | Path to SQLite database file. Use with volume mount | | | No | | Server bind address. Set to for containers | | | No | | Server port | | | Recommended | Auto-generated | Session encryption key (64+ chars). Must persist across restarts | | | Optional | | Base URL of your application (used for OAuth redirect URIs and client metadata). Use for loopback mode | | | Optional | | Set to for local development without ngrok. Uses loopback client IDs instead of client metadata URLs | | | Optional | | PLC directory URL override (useful for self-hosted PLC directories) | ### Critical Environment Variables - DATABASEURL: Must point to a persistent volume location - SECRETKEY_BASE: Generate with . Store as a secret and keep persistent - HOST: Set to in container environments ## SQLite Volume Setup SQLite requires persistent storage for three files: - - Main database file - - Shared memory file - - Write-ahead log IMPORTANT: Without persistent storage, all data will be lost on container restart. ## Fly.io ### 1. Create a volume ### 2. Configure fly.toml Create in your project root: ### 3. Set secrets ### 4. Deploy ### 5. Verify health ## Railway ### 1. Create a new project Connect your GitHub repository or deploy from the CLI. ### 2. Configure environment variables In the Railway dashboard, add these variables: ### 3. Add a volume In the Railway dashboard: 1. Go to your service settings 2. Add a volume mount 3. Mount path: 4. Size: 10GB (or as needed) ### 4. Configure health check In the service settings, set the health check path to . ### 5. Deploy Railway will automatically deploy when you push to your connected branch. ### Optional: railway.json Create for declarative configuration: ## Docker Compose (Self-Hosted) For self-hosted deployments, use the published Docker image: Create a file for secrets: Start the service: ## Post-Deployment ### Health check Verify the service is running: Expected response: ### Access GraphiQL Navigate to (requires authentication). ### Database access Fly.io: Railway: Use the Railway CLI or connect via SSH from the dashboard. Docker: ### Logs Fly.io: Railway: View logs in the dashboard or use . Docker: ## Backfill Configuration Control memory usage during backfill operations with these environment variables: | Variable | Default | Description | |----------|---------|-------------| | | 10 | Max concurrent PDS endpoints being processed | | | 4 | Max concurrent repo fetches per PDS | | | 50 | Global HTTP request limit | | | 60 | Timeout per repo fetch (seconds) | ### Recommended Settings by VPS Size 1GB RAM (e.g., Railway starter): 2GB RAM: 4GB+ RAM: ## Resource Requirements Minimum: - Memory: 1GB - CPU: 1 shared core - Disk: 10GB volume (for SQLite database) Recommendations: - Scale memory for high-traffic deployments - Use SSD-backed volumes for SQLite performance - Monitor database size and scale volume as needed","headings":[]},{"path":"/mcp","title":"MCP","group":"Other","content":"MCP Server Quickslice provides an MCP (Model Context Protocol) server that lets AI assistants query your ATProto data directly. ## Endpoint Any quickslice instance exposes MCP at . For example: ## Setup ### Claude Code ### Other MCP Clients Point any MCP-compatible client at the endpoint using HTTP transport. ## Available Tools | Tool | Description | |------|-------------| | | List all registered lexicons | | | Get full lexicon definition by NSID | | | List available GraphQL queries | | | Get OAuth flows, scopes, and endpoints | | | Get server version and features | | | Get full GraphQL schema | | | Execute a GraphQL query | ## Example Prompts Once connected, you can ask things like: - \"What lexicons are registered?\" - \"Show me the schema for xyz.statusphere.status\" - \"Query the latest 10 statusphere statuses\" - \"What GraphQL queries are available?\" - \"What OAuth scopes does this server support?\"","headings":[]}]