[{"path":"/","title":"Introduction","group":"Getting Started","content":"Quickslice Quickslice is a quick way to spin up an \\1 for AT Protocol applications. Import your Lexicon schemas and you get a GraphQL API with OAuth authentication, real-time sync from the network, and joins across record types without setting up a database or writing any backend code. ## The Problem Building an AppView from scratch means writing a lot of infrastructure code: - Jetstream connection and event handling - Record ingestion and validation - Database schema design and normalization - XRPC API endpoints for querying and writing data - OAuth session management and PDS writes - Efficient batching when resolving related records This adds up before you write any application logic. There are also a lot of patterns that are more or less the same that every AppView will need to implement. ## What Quickslice Does Quickslice handles all of that automatically: - \\1 and tracks the record types defined in your Lexicons - \\1 relevant records into a database (SQLite, more soon) - \\1 queries, mutations, and subscriptions from your Lexicon definitions - \\1 and writes records back to the user's PDS - \\1 by DID, URI, or strong reference, so you can query a status and its author's profile in one request ## When to Use It - You've setup tried and failed to build an AppView from scratch - You just want to tinker with Lexicon data structures and build a quick prototype - You've banged your head against OAuth for too long - You just want to ship your AppView already - The \\1 is the limit! ## Next Steps \\1: A hands-on tutorial showing what Quickslice handles for you","headings":[]},{"path":"/tutorial","title":"Tutorial","group":"Getting Started","content":"Tutorial: Build Statusphere with Quickslice Let's build Statusphere, an app where users share their current status as an emoji. This is the same app from the \\1, but using Quickslice as the AppView. Along the way, we'll show what you'd write manually versus what Quickslice handles automatically. ## What We're Building Statusphere lets users: - Log in with their AT Protocol identity - Set their status as an emoji - See a feed of everyone's statuses with profile information By the end of this tutorial, you'll understand how Quickslice eliminates the boilerplate of building an AppView. ## Step 1: Project Setup and Importing Lexicons Every AT Protocol app starts with Lexicons. Here's the Lexicon for a status record: When you import this Lexicon into Quickslice, several things happen automatically: 1. \\1: Quickslice starts tracking records from the network 2. \\1: A normalized table is created with proper columns and indexes 3. \\1: Query, mutation, and subscription types are generated | Without Quickslice | With Quickslice | |---|---| | Write Jetstream connection code | Import your Lexicon | | Filter events for your collection | | | Validate incoming records | | | Design database schema | Quickslice handles the rest. | | Write ingestion logic | | ## Step 2: Querying Status Records Once records are indexed, you can query them with GraphQL. Quickslice generates a query for each Lexicon type using Relay-style connections: The and pattern comes from \\1, a GraphQL specification for paginated data. Each contains a (the actual record) and a for pagination. You can filter with clauses: | Without Quickslice | With Quickslice | |---|---| | Design query API | Query is auto-generated: | | Write database queries | | | Handle pagination logic | | | Build filtering and sorting | | ## Step 3: Joining Profile Data This is where Quickslice really shines. Every status record has a field identifying its author. We want to show the author's display name alongside their status. In Bluesky, profile information lives in records. With Quickslice, you can join directly from a status to its author's profile: The field is a \\1. It follows the on the status record to find the corresponding profile record authored by the same identity. Behind the scenes, Quickslice: - Collects all DIDs from the status records - Batches them into a single database query (DataLoader pattern) - Joins the profile data efficiently | Without Quickslice | With Quickslice | |---|---| | Collect DIDs from status records | Add join to your query: | | Batch resolve DIDs to profiles | | | Handle N+1 query problem | | | Write batching logic | | | Join data in API response | | ### Other Join Types DID joins are just one option. Quickslice also supports: - \\1: Follow a URI or strong ref to another record - \\1: Find all records that reference a given record See the \\1 for complete documentation. ## Step 4: Writing a Status (Mutations) When a user wants to set their status, your app calls a mutation: When this mutation runs, Quickslice: 1. \\1: The record is created in their personal data repository 2. \\1: The record appears in queries immediately, without waiting for Jetstream 3. \\1: The authenticated session is used to sign the write | Without Quickslice | With Quickslice | |---|---| | Get OAuth session/agent | Call the mutation: | | Construct record with $type | | | Call putRecord on PDS | | | Optimistically update local DB | | | Handle errors | | ## Step 5: Authentication Quickslice handles AT Protocol OAuth. Your frontend initiates login, and Quickslice manages the authorization flow: 1. User enters their handle (e.g., ) 2. Your app redirects to Quickslice's OAuth endpoint 3. Quickslice redirects to the user's PDS for authorization 4. User approves the app 5. PDS redirects back to Quickslice with an auth code 6. Quickslice exchanges the code for tokens and establishes a session For authenticated queries and mutations, include the appropriate auth headers. The exact headers depend on which OAuth flow you're using (DPoP or Bearer token). See the \\1 for setup details. ## Step 6: Deploying to Railway The fastest way to deploy is with Railway: 1. Click the deploy button in the \\1 2. Generate an OAuth signing key with 3. Paste the key into the environment variable 4. Generate a domain and redeploy 5. Create your admin account by logging in 6. Upload your Lexicons See \\1 for detailed instructions. ## What You Didn't Write By using Quickslice, you skipped writing: - \\1: Connecting to the firehose, filtering events, handling reconnection - \\1: Checking incoming records against Lexicon schemas - \\1: Designing tables, migrations, indexes - \\1: Endpoints for filtering, sorting, and pagination - \\1: Efficient resolution of related records - \\1: Indexing records before Jetstream confirmation - \\1: Token exchange, session management, DPoP proofs With Quickslice, you focus on your application logic instead of infrastructure. ## Next Steps - \\1: Filtering, sorting, and pagination - \\1: Forward, reverse, and DID joins - \\1: Creating, updating, and deleting records - \\1: Setting up OAuth - \\1: Production configuration","headings":[]},{"path":"/guides/queries","title":"Queries","group":"Guides","content":"Queries Quickslice generates a GraphQL query for each record type Lexicon you import. Queries are public and don't require authentication. ## Relay Connections Queries return data in the \\1 format: - : Array of results, each containing a (the record) and (for pagination) - : Pagination metadata - : Total number of matching records ## Filtering Use the argument to filter records: ### Filter Operators | Operator | Description | Example | |----------|-------------|---------| | | Equal to | | | | Not equal to | | | | In array | | | | String contains (case-insensitive) | | | | Greater than | | | | Less than | | | | Greater than or equal | | | | Less than or equal | | ### Multiple Conditions Combine multiple conditions (they're ANDed together): ## Sorting Use to order results: ### Multi-Field Sorting Sort by multiple fields (applied in order): ## Pagination ### Forward Pagination Use to limit results and to get the next page: ### Backward Pagination Use and to paginate backward: ### PageInfo Fields | Field | Description | |-------|-------------| | | More items exist after this page | | | More items exist before this page | | | Cursor of the first item | | | Cursor of the last item | ## Complete Example Combining filtering, sorting, and pagination: Variables:","headings":[]},{"path":"/guides/joins","title":"Joins","group":"Guides","content":"Joins AT Protocol data is organized into collections. A user's status records live in one collection, their profile in another. Quickslice generates joins that let you query across collections, so you can fetch a status and its author's profile in a single request. ## Join Types Quickslice generates three types of joins automatically: | Type | What it does | Field naming | |------|--------------|--------------| | \\1 | Follows a URI or strong ref to another record | | | \\1 | Finds all records that reference a given record | | | \\1 | Finds records by the same author | | ## Forward Joins Forward joins follow references from one record to another. When a record has a field containing an AT-URI or strong ref, Quickslice generates a field to fetch the referenced record. ### Example: Resolving a Favorite's Subject A favorite record has a field containing an AT-URI. The field fetches the actual record: Forward joins return a union type because the referenced record could be any type. Use inline fragments ( ) to access type-specific fields. ## Reverse Joins Reverse joins work in the opposite direction: given a record, find all records that reference it. Quickslice analyzes your Lexicons and generates reverse join fields automatically. Reverse joins return paginated connections with support for filtering, sorting, and cursor-based pagination. ### Example: Comments on a Photo Find all comments that reference a specific photo: ### Sorting and Filtering Reverse Joins Reverse joins support the same sorting and filtering as top-level queries: ## DID Joins DID joins connect records by their author's identity. Every record has a field identifying who created it. Quickslice generates fields to find related records by the same author. ### Example: Author Profile from a Status Get the author's profile alongside their status: ### Unique vs Non-Unique DID Joins Some collections have exactly one record per DID (like profiles with a key). These return a single object: Other collections can have multiple records per DID. These return paginated connections: ### Cross-Lexicon DID Joins DID joins work across different Lexicon families. Get a user's Bluesky profile alongside their app-specific data: ## Common Patterns ### Profile Lookups The most common pattern: joining author profiles to any record type. ### Engagement Counts Use reverse joins to count likes, comments, or other engagement: ### User Activity Get all records by a user across multiple collections: ## How Batching Works Quickslice batches join resolution to avoid the N+1 query problem. When you query 100 photos with author profiles: 1. Fetches 100 photos in one query 2. Collects all unique DIDs from those photos 3. Fetches all profiles in a single query: 4. Maps profiles back to their photos This happens automatically for all join types.","headings":[]},{"path":"/guides/mutations","title":"Mutations","group":"Guides","content":"Mutations Mutations write records to the authenticated user's repository. All mutations require authentication. ## Creating Records When you create a record, Quickslice: 1. Writes the record to the user's PDS 2. Indexes the record locally for immediate query availability ### Custom Record Keys By default, Quickslice generates a TID (timestamp-based ID) for the record key. You can specify a custom key: Some Lexicons require specific key patterns. For example, profiles use as the record key. ## Updating Records Update an existing record by its record key: The update replaces the entire record. Include all required fields, not just the ones you're changing. ## Deleting Records Delete a record by its record key: ## Working with Blobs Records can include binary data like images. Upload the blob first, then reference it in your record. ### Upload a Blob The field accepts base64-encoded binary data. The response includes a (CID) to use in your record. ### Use the Blob in a Record See the \\1 for more details on blob handling and URL presets. ## Error Handling Common mutation errors: | Error | Cause | |-------|-------| | | Missing or invalid authentication token | | | Invalid input (missing required fields, wrong types) | | | Record doesn't exist (for update/delete) | | | Trying to modify another user's record | ## Authentication Mutations require authentication. The headers you include depend on the OAuth flow: \\1 (recommended for browser apps): \\1: See the \\1 for details on each flow and how to obtain tokens.","headings":[]},{"path":"/guides/authentication","title":"Authentication","group":"Guides","content":"Authentication Quickslice acts as an OAuth proxy between your app and users' Personal Data Servers (PDS). Your app never handles AT Protocol credentials directly. ## How It Works 1. User clicks login in your app 2. Your app redirects to Quickslice's endpoint 3. Quickslice redirects to the user's PDS for authorization 4. User enters credentials and approves your app 5. PDS redirects back to Quickslice with an auth code 6. Quickslice exchanges the code for tokens 7. Quickslice redirects back to your app with a code 8. Your app exchanges the code for an access token The access token authorizes mutations that write records to the user's repository. ## Setting Up OAuth ### Generate a Signing Key Quickslice needs a private key to sign OAuth tokens. Generate one with : Set the output as your environment variable. ### Register an OAuth Client 1. Open your Quickslice instance and navigate to \\1 2. Scroll to \\1 and click \\1 3. Fill in the form: - \\1: Your app's name - \\1: Public (browser apps) or Confidential (server apps) - \\1: Where users return after auth (e.g., ) - \\1: Leave as 4. Copy the \\1 ### Public vs Confidential Clients | Type | Use Case | Secret | |------|----------|--------| | \\1 | Browser apps, mobile apps | No secret (can't be kept secure on client) | | \\1 | Server-side apps, backend services | Has secret (stored securely on server) | ## Using the Client SDK The Quickslice client SDK handles OAuth, PKCE, DPoP, token refresh, and GraphQL requests. ### Install Or via CDN: ### Initialize ### Login ### Handle the Callback After authentication, the user returns to your redirect URI: ### Check Authentication State ### Logout ## Making Authenticated Requests ### With the SDK The SDK handles authentication headers automatically: ### Without the SDK If you're not using the SDK, include the appropriate headers based on your OAuth flow: \\1 (public clients): \\1 (confidential clients): ## The Viewer Query The query returns the authenticated user: Returns when not authenticated (no error thrown). ## Security: PKCE and DPoP The SDK implements two security mechanisms for browser apps: \\1 prevents authorization code interception. Before redirecting, the SDK generates a random secret and sends only its hash to the server. When exchanging the code for tokens, the SDK proves it initiated the request. \\1 binds tokens to a cryptographic key in your browser. Each request includes a signed proof. Even if an attacker steals your access token, they can't use it without the key. ## OAuth Endpoints - - Start the OAuth flow - - Exchange authorization code for tokens - - Server metadata - - Client metadata","headings":[]},{"path":"/guides/deployment","title":"Deployment","group":"Guides","content":"Deployment This guide covers deploying Quickslice to production. The quickest path is Railway with the one-click deploy button. ## Railway (Recommended) ### 1. Deploy Click the button to create a new Quickslice instance: \\1](https://railway.com/deploy/quickslice?referralCode=Ofii6e&utm\\1source=template&utm_campaign=generic) Railway will prompt you to configure environment variables. Leave the form open while you generate a signing key. ### 2. Generate OAuth Signing Key Quickslice needs a private key to sign OAuth tokens: Paste the output into the field in Railway, then click \\1. ### 3. Configure Your Domain After deployment completes: 1. Click on your quickslice service 2. Go to \\1 3. Click \\1 under Networking Railway creates a public URL like . \\1 1. Go to \\1 2. Click the three-dot menu on the latest deployment 3. Select \\1 ### 4. Create Admin Account Visit your domain. You'll see a welcome screen prompting you to create an admin account: 1. Enter your AT Protocol handle (e.g., ) 2. Click \\1 3. Authorize Quickslice on your PDS 4. You're now the instance admin ### 5. Configure Your Instance From the homepage, go to \\1: 1. Enter your \\1 in reverse-domain format (e.g., ) 2. Upload your Lexicons as a file 3. Click \\1 to import existing records from the network ## Environment Variables | Variable | Required | Default | Description | |----------|----------|---------|-------------| | | Yes | - | P-256 private key for signing OAuth tokens | | | No | | Path to SQLite database | | | No | | Server bind address (use for containers) | | | No | | Server port | | | Recommended | Auto-generated | Session encryption key (64+ chars) | | | No | Auto-detected | Public URL for OAuth redirects | ## Fly.io ### 1. Create a Volume ### 2. Configure fly.toml ### 3. Set Secrets ### 4. Deploy ## Docker Compose For self-hosted deployments: Create a file: Start: ## Backfill Configuration NOTE: These configurations are still a work in progress. If your container instance is running low on memory/crashes, consider reducing the number of concurrent workers and requests. Control memory usage during backfill with these variables: | Variable | Default | Description | |----------|---------|-------------| | | 10 | Max concurrent PDS endpoints | | | 4 | Max concurrent repo fetches per PDS | | | 50 | Global HTTP request limit | \\1 \\1 Use defaults or increase values. ## Resource Requirements \\1 - Memory: 1GB - CPU: 1 shared core - Disk: 10GB volume \\1 - Use SSD-backed volumes for SQLite performance - Monitor database size and scale volume as needed","headings":[]},{"path":"/guides/patterns","title":"Patterns","group":"Guides","content":"Common Patterns Recipes for common use cases when building with Quickslice. ## Profile Lookups Join author profiles to any record type to display names and avatars. This works for any record type. The field is available on all records because every record has a field. ## User Timelines Fetch all records by a specific user using DID joins from their profile. ## Engagement Counts Use reverse joins with to show likes, comments, or other engagement metrics. ## Feed with Nested Data Build a rich feed by combining multiple join types. ## Paginated Lists Implement infinite scroll or \"load more\" with cursor-based pagination. First request: Subsequent requests: Continue until is . ## Filtered Search Combine multiple filters for search functionality. ## Date Range Queries Filter records within a time period. Variables: ## Current User's Data Use the query to get the authenticated user's records. ## Real-Time Updates Subscribe to new records and update your UI in real-time. Combine with an initial query to show existing data, then append new records as they arrive. ## Aggregations Get statistics like top items or activity over time.","headings":[]},{"path":"/guides/troubleshooting","title":"Troubleshooting","group":"Guides","content":"Troubleshooting Common issues and how to resolve them. ## OAuth Errors ### \"Invalid redirect URI\" The redirect URI in your OAuth request doesn't match any registered URI for your client. \\1 Check that the redirect URI in your app exactly matches one registered in Settings > OAuth Clients. URIs must match including protocol, host, port, and path. ### \"Invalid client ID\" The client ID doesn't exist or was deleted. \\1 Verify the client ID in Settings > OAuth Clients. If it was deleted, register a new client. ### \"PKCE code verifier mismatch\" The code verifier sent during token exchange doesn't match the code challenge from authorization. \\1 This usually means the code verifier wasn't stored correctly between the authorization redirect and callback. If using the SDK, ensure you're calling in the same browser session that initiated login. ### \"DPoP proof invalid\" The DPoP proof header is missing, malformed, or signed with the wrong key. \\1 If using the SDK, this is handled automatically. If implementing manually, ensure: - The DPoP header contains a valid JWT - The JWT is signed with the same key used during token exchange - The and claims match the request method and URL ## GraphQL Errors ### \"Cannot query field X on type Y\" The field doesn't exist on the type you're querying. \\1 Check your query against the schema in GraphiQL. Common causes: - Typo in field name - Field exists on a different type (use inline fragments for unions) - Lexicon wasn't imported yet ### \"Variable $X of type Y used in position expecting Z\" Type mismatch between your variable declaration and how it's used. \\1 Check variable types in your query definition. Common issues: - Using instead of for date fields - Missing for required variables - Using wrong scalar type ### \"Record not found\" The record you're trying to update or delete doesn't exist. \\1 Verify the record key (rkey) is correct. You can query for the record first to confirm it exists. ## Jetstream Issues ### Records not appearing after creation Records created via mutation should appear immediately due to optimistic indexing. If they don't: \\1 1. Was the mutation successful? Check the response for errors. 2. Is the record in the user's PDS? Use to verify. 3. Is Jetstream connected? Check the logs for connection errors. ### Old records missing Records created before you deployed Quickslice won't appear until backfilled. \\1 Trigger a backfill from the admin UI or wait for the scheduled backfill to complete. ### Backfill stuck or slow \\1 1. Memory usage - backfill is memory-intensive. See \\1 for tuning. 2. Network connectivity to PDS endpoints 3. Logs for specific PDS errors ## Database Issues ### \"Database is locked\" SQLite can't acquire a write lock. Usually caused by long-running queries or concurrent access issues. \\1 - Ensure only one Quickslice instance writes to the database - Check for stuck queries in logs - Restart the service if needed ### Disk space full SQLite needs space for WAL files and vacuuming. \\1 Expand your volume. See your hosting platform's documentation. ## Debugging Tips ### Check if records are being indexed Query for recent records: ### Verify OAuth is working Query the viewer: Returns if not authenticated. Returns user info if authenticated. ### Inspect the GraphQL schema Use GraphiQL at to explore available types, queries, and mutations. The Docs panel shows all fields and their types. ### Check Lexicon registration Use the MCP endpoint or admin UI to list registered Lexicons: Look for types matching your Lexicon NSIDs (e.g., ). ## FAQ ### \"Why aren't my records showing up?\" 1. \\1 Should appear immediately. Check mutation response for errors. 2. \\1 Needs backfill. Trigger from admin UI. 3. \\1 Ensure the Lexicon is registered in your instance. ### \"Why is my mutation failing?\" 1. \\1 Token expired or invalid. Re-authenticate. 2. \\1 Trying to modify another user's record. 3. \\1 Check input against Lexicon schema. Required fields missing? ### \"How do I check what Lexicons are loaded?\" Go to Settings in the admin UI, or query via MCP:","headings":[]},{"path":"/reference/aggregations","title":"Aggregations","group":"Reference","content":"Aggregations All record types have a corresponding aggregation query: . For example, records can be aggregated with . Aggregation queries are public and do not require authentication. ## Basic Aggregation Group by a field to count occurrences: ## Filtering & Sorting Use to filter records, to sort by count, and to cap results. Get a user's top 10 artists for 2025: ## Multiple Fields Group by multiple fields simultaneously. Get top tracks with their artists: ## Date Truncation Group datetime fields by time intervals: , , , or . Get plays per month: ## Reference ### Query Structure - - Aggregation query for any record type - (required) - Array of fields to group by, with optional for datetime fields - (optional) - Filter conditions - (optional) - Sort by ( or ) - (optional) - Maximum groups to return (default: 100) ### Available Columns In addition to record fields, you can group by: , , , , , ### Validation - Date intervals can only be applied to datetime fields - Maximum 5 groupBy fields per query","headings":[]},{"path":"/reference/subscriptions","title":"Subscriptions","group":"Reference","content":"Subscriptions Subscriptions let your app receive real-time updates when records are created, updated, or deleted. Instead of polling for changes, the server pushes events to your client over a WebSocket connection. Connect to using the \\1 protocol. ## Basic Subscription ## Field Selection Request only the fields you need: Response: ## Named Subscription ## Subscription Types Each collection has three subscription fields: - - Fires when a new record is created - - Fires when a record is updated - - Fires when a record is deleted ### Examples ## With Joins Subscriptions support joins like queries: Response: ## WebSocket Protocol ### 1. Connect ### 2. Initialize ### 3. Subscribe ### 4. Receive Events ### 5. Unsubscribe","headings":[]},{"path":"/reference/blobs","title":"Blobs","group":"Reference","content":"Working with Blobs Blobs are used for binary data like images, videos, and files. They are uploaded separately and referenced by their CID (Content Identifier). ## Upload Blob Upload binary data encoded as base64: Response: ## Blob Reference A blob reference contains: - : CID of the blob content - : MIME type (e.g., , ) - : Size in bytes ## Using Blobs in Records ### Profile Avatar ### Profile Banner ## Blob URLs Blobs automatically generate CDN URLs for serving. Use the field with optional presets: ### Default URL Returns: ### Avatar Preset Returns: ### Banner Preset Returns: ## Available Presets - - Optimized for profile avatars (square, small) - - Optimized for profile banners (wide, medium) - - Thumbnails in feed view - - Full size images in feed (default) ## Complete Example: Update Profile with Images ### Step 1: Upload Avatar Variables: Response: ### Step 2: Upload Banner Variables: Response: ### Step 3: Update Profile Response: ## JavaScript Example","headings":[]},{"path":"/reference/variables","title":"Variables","group":"Reference","content":"Variables GraphQL variables allow you to parameterize your queries and mutations for reusability and security. ## Basic Variables ### Query with Variables Variables: ### Mutation with Variables Variables: ## Multiple Variables Variables: ## Optional Variables Use default values for optional variables: Variables: Or omit variables to use defaults: ## Blob Upload with Variables Variables: ## Update Profile with Variables Variables: ## Using in HTTP Requests When making HTTP requests, send variables in the request body:","headings":[]},{"path":"/reference/mcp","title":"MCP","group":"Reference","content":"MCP Server Quickslice provides an MCP (Model Context Protocol) server that lets AI assistants query your ATProto data directly. ## Endpoint Any quickslice instance exposes MCP at . For example: ## Setup ### Claude Code ### Other MCP Clients Point any MCP-compatible client at the endpoint using HTTP transport. ## Available Tools | Tool | Description | |------|-------------| | | List all registered lexicons | | | Get full lexicon definition by NSID | | | List available GraphQL queries | | | Get OAuth flows, scopes, and endpoints | | | Get server version and features | | | Get full GraphQL schema | | | Execute a GraphQL query | ## Example Prompts Once connected, you can ask things like: - \"What lexicons are registered?\" - \"Show me the schema for xyz.statusphere.status\" - \"Query the latest 10 statusphere statuses\" - \"What GraphQL queries are available?\" - \"What OAuth scopes does this server support?\"","headings":[]}]