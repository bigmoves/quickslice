<!doctype html>
<html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>quickslice - Joins</title><link href="/styles.css" rel="stylesheet"></head><body><button aria-label="Toggle menu" class="menu-toggle"><svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><line xmlns="http://www.w3.org/2000/svg" x1="3" x2="21" y1="6" y2="6"></line><line xmlns="http://www.w3.org/2000/svg" x1="3" x2="21" y1="12" y2="12"></line><line xmlns="http://www.w3.org/2000/svg" x1="3" x2="21" y1="18" y2="18"></line></svg></button><div class="sidebar-backdrop"></div><div class="container"><aside class="sidebar"><div class="sidebar-brand"><svg xmlns="http://www.w3.org/2000/svg" class="sidebar-logo" viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg"><defs xmlns="http://www.w3.org/2000/svg"><linearGradient xmlns="http://www.w3.org/2000/svg" id="board1" x1="0%" x2="100%" y1="0%" y2="100%"><stop xmlns="http://www.w3.org/2000/svg" offset="0%" stop-color="#FF6347" stop-opacity="1"></stop><stop xmlns="http://www.w3.org/2000/svg" offset="100%" stop-color="#FF4500" stop-opacity="1"></stop></linearGradient><linearGradient xmlns="http://www.w3.org/2000/svg" id="board2" x1="0%" x2="100%" y1="0%" y2="100%"><stop xmlns="http://www.w3.org/2000/svg" offset="0%" stop-color="#00CED1" stop-opacity="1"></stop><stop xmlns="http://www.w3.org/2000/svg" offset="100%" stop-color="#4682B4" stop-opacity="1"></stop></linearGradient></defs><g xmlns="http://www.w3.org/2000/svg" transform="translate(64, 64)"><ellipse xmlns="http://www.w3.org/2000/svg" cx="0" cy="-28" fill="url(#board1)" rx="50" ry="20"></ellipse><ellipse xmlns="http://www.w3.org/2000/svg" cx="0" cy="0" fill="url(#board2)" rx="60" ry="20"></ellipse><ellipse xmlns="http://www.w3.org/2000/svg" cx="0" cy="28" fill="#32CD32" rx="40" ry="20"></ellipse></g></svg><span class="sidebar-title">quickslice</span></div><nav><ul><li><a href="/">Getting Started</a></li><li><a href="/authentication">Authentication</a></li><li><a href="/queries">Queries</a></li><li><a href="/mutations">Mutations</a></li><li><a class="active" href="/joins">Joins</a></li><li><a href="/aggregations">Aggregations</a></li><li><a href="/subscriptions">Subscriptions</a></li><li><a href="/blobs">Blobs</a></li><li><a href="/variables">Variables</a></li><li><a href="/deployment">Deployment</a></li><li><a href="/mcp">MCP</a></li></ul></nav></aside><main class="content"><div><h1 id="Joins">Joins</h1>
<p>quickslice automatically generates <strong>forward joins</strong>, <strong>reverse joins</strong>, and <strong>DID joins</strong> based on AT Protocol lexicon schemas, allowing you to traverse relationships between records.</p>
<h2 id="Overview">Overview</h2>
<ul>
<li>
<p><strong>Forward Joins</strong>: Follow references from one record to another (e.g., post → parent post)</p>
<ul>
<li>Returns: Single object or <code>Record</code> union</li>
<li>Naming: <code>{fieldName}Resolved</code></li>
</ul>
</li>
<li>
<p><strong>Reverse Joins</strong>: Discover records that reference a given record (e.g., post → all likes on that post)</p>
<ul>
<li>Returns: <strong>Paginated Connection</strong> with sorting, filtering, and pagination</li>
<li>Naming: <code>{SourceType}Via{FieldName}</code></li>
</ul>
</li>
<li>
<p><strong>DID Joins</strong>: Find records that share the same author (DID)</p>
<ul>
<li>Returns: Single object (unique DID) or <strong>Paginated Connection</strong> (non-unique DID)</li>
<li>Naming: <code>{CollectionName}ByDid</code></li>
</ul>
</li>
<li>
<p><strong>Union Types</strong>: Forward joins return a <code>Record</code> union, allowing type-specific field access via inline fragments</p>
</li>
</ul>
<h2 id="Forward-Joins">Forward Joins</h2>
<p>Forward joins are generated for fields that reference other records via:</p>
<ul>
<li><code>at-uri</code> format strings</li>
<li><code>strongRef</code> objects</li>
</ul>
<h3 id="Basic-Forward-Join">Basic Forward Join</h3>
<p>When a field references another record, quickslice creates a <code>*Resolved</code> field:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        replyTo              # The at-uri string
        replyToResolved {    # The resolved record
          uri
        }
      }
    }
  }
}
</code></pre>
<h3 id="Union-Types--Inline-Fragments">Union Types &amp; Inline Fragments</h3>
<p>Forward join fields return a <code>Record</code> union type because the referenced record could be any type. Use inline fragments to access type-specific fields:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        replyToResolved {
          # Access fields based on the actual type
          ... on AppBskyFeedPost {
            uri
            text
            createdAt
          }
          ... on AppBskyFeedLike {
            uri
            subject
            createdAt
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="StrongRef-Forward-Joins">StrongRef Forward Joins</h3>
<p>StrongRef fields (containing <code>uri</code> and <code>cid</code>) are resolved automatically:</p>
<pre><code class="language-graphql">query {
  appBskyActorProfile {
    edges {
      node {
        displayName
        pinnedPost {
          uri    # Original strongRef uri
          cid    # Original strongRef cid
        }
        pinnedPostResolved {
          ... on AppBskyFeedPost {
            uri
            text
            likeCount
          }
        }
      }
    }
  }
}
</code></pre>
<h2 id="Reverse-Joins">Reverse Joins</h2>
<p>Reverse joins are automatically discovered by analyzing all lexicons. They allow you to find all records that reference a given record. <strong>Reverse joins return paginated connections</strong> with support for sorting, filtering, and cursor-based pagination.</p>
<h3 id="Basic-Reverse-Join">Basic Reverse Join</h3>
<p>Reverse join fields are named: <code>{SourceType}Via{FieldName}</code> and return a Connection type:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        # Find all likes that reference this post via their 'subject' field
        appBskyFeedLikeViaSubject(first: 20) {
          totalCount  # Total number of likes
          edges {
            node {
              uri
              createdAt
            }
            cursor
          }
          pageInfo {
            hasNextPage
            hasPreviousPage
            startCursor
            endCursor
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="Multiple-Reverse-Joins">Multiple Reverse Joins</h3>
<p>A record type can have multiple reverse join fields. You can request different page sizes for each:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        # Get first 10 replies
        appBskyFeedPostViaReplyTo(first: 10) {
          totalCount
          edges {
            node {
              uri
              text
            }
          }
        }
        # Get first 20 likes
        appBskyFeedLikeViaSubject(first: 20) {
          totalCount
          edges {
            node {
              uri
              createdAt
            }
          }
        }
        # Get first 20 reposts
        appBskyFeedRepostViaSubject(first: 20) {
          totalCount
          edges {
            node {
              uri
              createdAt
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="Reverse-Joins-with-StrongRef">Reverse Joins with StrongRef</h3>
<p>Reverse joins work with strongRef fields too. You can also use sorting and filtering:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        # Find all profiles that pinned this post
        appBskyActorProfileViaPinnedPost(
          sortBy: [{field: &quot;indexedAt&quot;, direction: DESC}]
        ) {
          totalCount
          edges {
            node {
              uri
              displayName
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="Sorting-Reverse-Joins">Sorting Reverse Joins</h3>
<p>You can sort reverse join results by any field in the joined collection:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        # Get most recent likes first
        appBskyFeedLikeViaSubject(
          first: 10
          sortBy: [{field: &quot;createdAt&quot;, direction: DESC}]
        ) {
          edges {
            node {
              uri
              createdAt
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="Filtering-Reverse-Joins">Filtering Reverse Joins</h3>
<p>Use <code>where</code> filters to narrow down nested join results:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        # Only get likes from a specific user
        appBskyFeedLikeViaSubject(
          where: { did: { eq: &quot;did:plc:abc123&quot; } }
        ) {
          totalCount  # Likes from this specific user
          edges {
            node {
              uri
              createdAt
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h2 id="DID-Joins">DID Joins</h2>
<p>DID joins allow you to traverse relationships between records that share the same author (DID). These are automatically generated for all collection pairs and are named: <code>{CollectionName}ByDid</code></p>
<h3 id="Two-Types-of-DID-Joins">Two Types of DID Joins</h3>
<h4 id="1-Unique-DID-Joins-literalself-key">1. Unique DID Joins (literal:self key)</h4>
<p>Collections with a <code>literal:self</code> key (like profiles) have only one record per DID. These return a <strong>single nullable object</strong> (no pagination needed):</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        # Get the author's profile (single object, not paginated)
        appBskyActorProfileByDid {
          uri
          displayName
          bio
        }
      }
    }
  }
}
</code></pre>
<h4 id="2-Non-Unique-DID-Joins">2. Non-Unique DID Joins</h4>
<p>Most collections can have multiple records per DID. These return <strong>paginated connections</strong> with full support for sorting, filtering, and pagination:</p>
<pre><code class="language-graphql">query {
  appBskyActorProfile {
    edges {
      node {
        displayName
        # Get all posts by this user (paginated)
        appBskyFeedPostByDid(
          first: 10
          sortBy: [{field: &quot;indexedAt&quot;, direction: DESC}]
        ) {
          totalCount  # Total posts by this user
          edges {
            node {
              uri
              text
              indexedAt
            }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="DID-Join-with-Filtering">DID Join with Filtering</h3>
<p>Combine DID joins with filters to find specific records:</p>
<pre><code class="language-graphql">query {
  appBskyActorProfile(where: { did: { eq: &quot;did:plc:abc123&quot; } }) {
    edges {
      node {
        displayName
        # Get only posts containing &quot;gleam&quot;
        appBskyFeedPostByDid(
          where: { text: { contains: &quot;gleam&quot; } }
          sortBy: [{field: &quot;indexedAt&quot;, direction: DESC}]
        ) {
          totalCount  # Posts mentioning &quot;gleam&quot;
          edges {
            node {
              text
              indexedAt
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="Cross-Collection-DID-Queries">Cross-Collection DID Queries</h3>
<p>DID joins work across all collection pairs, enabling powerful cross-collection queries:</p>
<pre><code class="language-graphql">query {
  appBskyActorProfile {
    edges {
      node {
        displayName
        # All their posts
        appBskyFeedPostByDid(first: 10) {
          totalCount
          edges {
            node {
              text
            }
          }
        }
        # All their likes
        appBskyFeedLikeByDid(first: 10) {
          totalCount
          edges {
            node {
              subject
            }
          }
        }
        # All their reposts
        appBskyFeedRepostByDid(first: 10) {
          totalCount
          edges {
            node {
              subject
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="DID-Join-Arguments">DID Join Arguments</h3>
<p>Non-unique DID joins support all standard connection arguments:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>first</code></td>
<td><code>Int</code></td>
<td>Number of records to return (forward pagination)</td>
</tr>
<tr>
<td><code>after</code></td>
<td><code>String</code></td>
<td>Cursor for forward pagination</td>
</tr>
<tr>
<td><code>last</code></td>
<td><code>Int</code></td>
<td>Number of records to return (backward pagination)</td>
</tr>
<tr>
<td><code>before</code></td>
<td><code>String</code></td>
<td>Cursor for backward pagination</td>
</tr>
<tr>
<td><code>sortBy</code></td>
<td><code>[SortFieldInput!]</code></td>
<td>Sort by any field in the collection</td>
</tr>
<tr>
<td><code>where</code></td>
<td><code>WhereInput</code></td>
<td>Filter nested records</td>
</tr>
</tbody>
</table>
<h2 id="Complete-Example">Complete Example</h2>
<p>Combining forward joins, reverse joins, and DID joins to build a rich thread view:</p>
<pre><code class="language-graphql">query GetThread($postUri: String!) {
  appBskyFeedPost(where: { uri: { eq: $postUri } }) {
    edges {
      node {
        uri
        text
        createdAt

        # DID join: Get the author's profile
        appBskyActorProfileByDid {
          displayName
          bio
        }

        # Forward join: Get the parent post
        replyToResolved {
          ... on AppBskyFeedPost {
            uri
            text
            createdAt
          }
        }

        # Reverse join: Get first 10 replies
        appBskyFeedPostViaReplyTo(
          first: 10
          sortBy: [{field: &quot;createdAt&quot;, direction: ASC}]
        ) {
          totalCount  # Total replies
          edges {
            node {
              uri
              text
              createdAt
            }
          }
          pageInfo {
            hasNextPage
          }
        }

        # Reverse join: Get first 20 likes
        appBskyFeedLikeViaSubject(first: 20) {
          totalCount  # Like count
          edges {
            node {
              uri
              createdAt
            }
          }
        }

        # Reverse join: Get reposts
        appBskyFeedRepostViaSubject(first: 20) {
          totalCount  # Repost count
          edges {
            node {
              uri
              createdAt
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h2 id="DataLoader-Batching">DataLoader Batching</h2>
<p>All joins use DataLoader for efficient batching:</p>
<pre><code class="language-graphql"># This query will batch all replyToResolved lookups into a single database query
query {
  appBskyFeedPost(first: 100) {
    edges {
      node {
        uri
        text
        replyToResolved {
          ... on AppBskyFeedPost {
            uri
            text
          }
        }
      }
    }
  }
}
</code></pre>
<p><strong>How it works:</strong></p>
<ol>
<li>Fetches 100 posts</li>
<li>Collects all unique <code>replyTo</code> URIs</li>
<li>Batches them into a single SQL query: <code>WHERE uri IN (...)</code></li>
<li>Returns resolved records efficiently</li>
</ol>
<h2 id="Performance-Tips">Performance Tips</h2>
<h3 id="1-Only-Request-What-You-Need">1. Only Request What You Need</h3>
<pre><code class="language-graphql"># Good: Only request specific fields
query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        appBskyFeedLikeViaSubject(first: 20) {
          totalCount  # Get count without fetching all records
          edges {
            node {
              uri  # Only need the URI
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="2-Use-totalCount-for-Metrics">2. Use totalCount for Metrics</h3>
<p>Get engagement counts efficiently without fetching all records:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        # Just get counts, no records
        likes: appBskyFeedLikeViaSubject(first: 0) {
          totalCount  # Like count
        }
        reposts: appBskyFeedRepostViaSubject(first: 0) {
          totalCount  # Repost count
        }
        replies: appBskyFeedPostViaReplyTo(first: 0) {
          totalCount  # Reply count
        }
      }
    }
  }
}
</code></pre>
<h3 id="3-Use-Pagination-on-Nested-Joins">3. Use Pagination on Nested Joins</h3>
<p>Nested joins are paginated by default. Always specify <code>first</code> or <code>last</code> for optimal performance:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost(first: 10) {
    edges {
      node {
        uri
        text
        # Limit nested join results
        appBskyFeedLikeViaSubject(first: 20) {
          totalCount  # Total likes
          edges {
            node {
              uri
            }
          }
          pageInfo {
            hasNextPage  # Know if there are more
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="4-Avoid-Deep-Nesting">4. Avoid Deep Nesting</h3>
<pre><code class="language-graphql"># Avoid: Deeply nested joins can be expensive
query {
  appBskyFeedPost {
    edges {
      node {
        replyToResolved {
          ... on AppBskyFeedPost {
            replyToResolved {
              ... on AppBskyFeedPost {
                replyToResolved {
                  # Too deep!
                }
              }
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h2 id="Type-Resolution">Type Resolution</h2>
<p>The <code>Record</code> union uses a type resolver that examines the <code>collection</code> field:</p>
<table>
<thead>
<tr>
<th>Collection</th>
<th>GraphQL Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>app.bsky.feed.post</code></td>
<td><code>AppBskyFeedPost</code></td>
</tr>
<tr>
<td><code>app.bsky.feed.like</code></td>
<td><code>AppBskyFeedLike</code></td>
</tr>
<tr>
<td><code>app.bsky.actor.profile</code></td>
<td><code>AppBskyActorProfile</code></td>
</tr>
</tbody>
</table>
<p>This allows inline fragments to work correctly:</p>
<pre><code class="language-graphql">{
  appBskyFeedPost {
    edges {
      node {
        replyToResolved {
          # Runtime type is determined by the collection field
          ... on AppBskyFeedPost { text }
          ... on AppBskyFeedLike { subject }
        }
      }
    }
  }
}
</code></pre>
<h2 id="Schema-Introspection">Schema Introspection</h2>
<p>Discover available joins using introspection:</p>
<pre><code class="language-graphql">query {
  __type(name: &quot;AppBskyFeedPost&quot;) {
    fields {
      name
      type {
        name
        kind
      }
    }
  }
}
</code></pre>
<p>Look for fields ending in:</p>
<ul>
<li><code>Resolved</code> (forward joins)</li>
<li><code>Via*</code> (reverse joins)</li>
<li><code>ByDid</code> (DID joins)</li>
</ul>
<h2 id="Common-Patterns">Common Patterns</h2>
<h3 id="Thread-Navigation">Thread Navigation</h3>
<pre><code class="language-graphql"># Get a post and its parent
query {
  appBskyFeedPost(where: { uri: { eq: $uri } }) {
    edges {
      node {
        uri
        text
        replyToResolved {
          ... on AppBskyFeedPost {
            uri
            text
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="Engagement-Metrics">Engagement Metrics</h3>
<p>Use <code>totalCount</code> to get efficient engagement counts without fetching all records:</p>
<pre><code class="language-graphql"># Get counts efficiently
query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        # Get like count
        likes: appBskyFeedLikeViaSubject(first: 0) {
          totalCount
        }
        # Get repost count
        reposts: appBskyFeedRepostViaSubject(first: 0) {
          totalCount
        }
        # Get reply count
        replies: appBskyFeedPostViaReplyTo(first: 0) {
          totalCount
        }
      }
    }
  }
}
</code></pre>
<p>Or fetch recent engagement with pagination:</p>
<pre><code class="language-graphql">query {
  appBskyFeedPost {
    edges {
      node {
        uri
        text
        # Get 10 most recent likes
        likes: appBskyFeedLikeViaSubject(
          first: 10
          sortBy: [{field: &quot;createdAt&quot;, direction: DESC}]
        ) {
          totalCount  # Total like count
          edges {
            node {
              did  # Who liked it
              createdAt
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="Users-Pinned-Content">User's Pinned Content</h3>
<pre><code class="language-graphql">query {
  appBskyActorProfile(where: { did: { eq: $did } }) {
    edges {
      node {
        displayName
        pinnedPostResolved {
          ... on AppBskyFeedPost {
            uri
            text
            createdAt
          }
        }
      }
    }
  }
}
</code></pre>
</div><nav aria-label="Page sections" class="minimap"><div class="minimap-header">On this page</div><a class="minimap-item" data-target-id="Overview" href="#Overview">Overview</a><a class="minimap-item" data-target-id="Forward-Joins" href="#Forward-Joins">Forward Joins</a><a class="minimap-item minimap-item-sub" data-target-id="Basic-Forward-Join" href="#Basic-Forward-Join">Basic Forward Join</a><a class="minimap-item minimap-item-sub" data-target-id="Union-Types--Inline-Fragments" href="#Union-Types--Inline-Fragments">Union Types &amp;amp; Inline Fragments</a><a class="minimap-item minimap-item-sub" data-target-id="StrongRef-Forward-Joins" href="#StrongRef-Forward-Joins">StrongRef Forward Joins</a><a class="minimap-item" data-target-id="Reverse-Joins" href="#Reverse-Joins">Reverse Joins</a><a class="minimap-item minimap-item-sub" data-target-id="Basic-Reverse-Join" href="#Basic-Reverse-Join">Basic Reverse Join</a><a class="minimap-item minimap-item-sub" data-target-id="Multiple-Reverse-Joins" href="#Multiple-Reverse-Joins">Multiple Reverse Joins</a><a class="minimap-item minimap-item-sub" data-target-id="Reverse-Joins-with-StrongRef" href="#Reverse-Joins-with-StrongRef">Reverse Joins with StrongRef</a><a class="minimap-item minimap-item-sub" data-target-id="Sorting-Reverse-Joins" href="#Sorting-Reverse-Joins">Sorting Reverse Joins</a><a class="minimap-item minimap-item-sub" data-target-id="Filtering-Reverse-Joins" href="#Filtering-Reverse-Joins">Filtering Reverse Joins</a><a class="minimap-item" data-target-id="DID-Joins" href="#DID-Joins">DID Joins</a><a class="minimap-item minimap-item-sub" data-target-id="Two-Types-of-DID-Joins" href="#Two-Types-of-DID-Joins">Two Types of DID Joins</a><a class="minimap-item minimap-item-sub" data-target-id="DID-Join-with-Filtering" href="#DID-Join-with-Filtering">DID Join with Filtering</a><a class="minimap-item minimap-item-sub" data-target-id="Cross-Collection-DID-Queries" href="#Cross-Collection-DID-Queries">Cross-Collection DID Queries</a><a class="minimap-item minimap-item-sub" data-target-id="DID-Join-Arguments" href="#DID-Join-Arguments">DID Join Arguments</a><a class="minimap-item" data-target-id="Complete-Example" href="#Complete-Example">Complete Example</a><a class="minimap-item" data-target-id="DataLoader-Batching" href="#DataLoader-Batching">DataLoader Batching</a><a class="minimap-item" data-target-id="Performance-Tips" href="#Performance-Tips">Performance Tips</a><a class="minimap-item minimap-item-sub" data-target-id="1-Only-Request-What-You-Need" href="#1-Only-Request-What-You-Need">1. Only Request What You Need</a><a class="minimap-item minimap-item-sub" data-target-id="2-Use-totalCount-for-Metrics" href="#2-Use-totalCount-for-Metrics">2. Use totalCount for Metrics</a><a class="minimap-item minimap-item-sub" data-target-id="3-Use-Pagination-on-Nested-Joins" href="#3-Use-Pagination-on-Nested-Joins">3. Use Pagination on Nested Joins</a><a class="minimap-item minimap-item-sub" data-target-id="4-Avoid-Deep-Nesting" href="#4-Avoid-Deep-Nesting">4. Avoid Deep Nesting</a><a class="minimap-item" data-target-id="Type-Resolution" href="#Type-Resolution">Type Resolution</a><a class="minimap-item" data-target-id="Schema-Introspection" href="#Schema-Introspection">Schema Introspection</a><a class="minimap-item" data-target-id="Common-Patterns" href="#Common-Patterns">Common Patterns</a><a class="minimap-item minimap-item-sub" data-target-id="Thread-Navigation" href="#Thread-Navigation">Thread Navigation</a><a class="minimap-item minimap-item-sub" data-target-id="Engagement-Metrics" href="#Engagement-Metrics">Engagement Metrics</a><a class="minimap-item minimap-item-sub" data-target-id="Users-Pinned-Content" href="#Users-Pinned-Content">User&#39;s Pinned Content</a></nav></main></div><script src="/highlight.js"></script><script src="/mobile-nav.js"></script><script src="/minimap.js"></script></body></html>